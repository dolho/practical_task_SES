# practical_task_SES
Practical task for software engineering school 

За основу для выполнения задания был взят микрофреймворк Flask, за свою минималистичность и 
гибкость в выборе инструментов. Для выполнения задания было создано два модуля (Blueprints, 
выражаясь в терминологии Flask): user (для регистрации, логина и подтверждения почты) и 
converter (для получения текущего курса биткоина к гривне).
Подробнее о модулях и их endpoints
1) User. 
	Create.
	Поскольку использование баз данных было запрещено условием, сохранение пользовательских
данных было реализовано как работа с .json файлами. Поскольку сохранять все данные в одном файле нерационально, ввиду сопряженных проблем с конкурентным доступом, файлы сохраняются по такому алгоритму: 
1. На основе email-а пользователя обчислить hash
2. Взять от полученного hash-a остаток от деления на число (в приложении это число
равняется 5 * 10^6)
3. Записать информацию в файл с полученным номером
4. В случае коллизии, дозаписать новый email к уже записаному
Не сложно заметить, что описанный механизм повторяет идею, на основе которой работают хэш-таблицы.
Все .json файлы сохраняются в одну директорию user_data. Интуитивно, хочется разделить эту директорию на поддиректории, с целью образования древовидной структры, что должно было бы упростить поиск файлов до сложности O(log(n)), но в реальности такого прироста не пройзойдет, поскольку ОС "под капотом" не выполняет поиск линейным сканированием. Ссылка на результаты сравнения записи и чтения 10 млн. файлов в плоскую и вложенную структуру директорий: https://medium.com/@hartator/benchmark-deep-directory-structure-vs-flat-directory-structure-to-store-millions-of-files-on-ext4-cac1000ca28. 
Пароль пользователя не хранится в открытом виде, а хешируется. Помимо информации про email и пароль, у пользователя сохраняется метка "is_activated", которая показывает подтвердил ли пользователь свой email. Что бы пользователь не ждал, пока ему отправится письмо, это делает отдельный worker в бэкграунде. Что бы данный worker получил информацию про email пользователя и токен подтверждения, используется distributed task queue Celery. Celery, при помощи брокера сообщений RabbitMQ, доставляет это сообщение для worker-a
	Login.
Для аутентификации пользователя используется Json Web Token. В payload токена лежит email, метка 'is_activated' и время истечения токена (которое равняется 15 минутам)
 	user/confirm/<token>
 Endpoint, который активирует аккаунт пользователя и меняет метку 'is_activated' с False на True
 На почту пользователю присылается уже готовая ссылка на этот endpoint.
2) btcRate 
	Модуль работает с api, который предоставляет криптовалютная биржа CoinBase. Поскольку котировки биржи обновляются раз в минуту, то нет нужды делать запрос на биржу при каждом запросе пользователя. Поэтому, при инициализации модуль запускает отдельный thread, в котором ровно раз в 60 секунд делается запрос на биржу и сохраняется результат, который и отдается пользователям при запросах. Модуль проверяет JWT, который передает пользователь. В случае, если пользователь не активировал свой email, модуль не вернет пользователю информацию о курсе.
	Unit-tests 
Помимо самих модулей было написано два юнит теста, которые проверяют: 
1. Попытку получить информацию о курсе не авторизовавшись.
2. Зарегестрироваться, залогиниться, получить информацию о курсе, активировать почту, получить информацию о курсе
Пароли и токены передаются в header-ах http-запросов. 
"Соль" для jwt, и токена подтвержедния email-a берется из переменных окружения
Endpoint-ы задокументированы при помощи swagger-a.

