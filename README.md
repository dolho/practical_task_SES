# practical_task_SES
Practical task for software engineering school 

За основу для выполнения задания был взят микрофреймворк Flask, за свою минималистичность и 
гибкость в выборе инструментов. Для выполнения задания было создано два модуля (Blueprints, 
выражаясь в терминологии Flask): user (для регистрации, логина и подтверждения почты) и 
converter (для получения текущего курса биткоина к гривне).  
Приложение было задеплоино на heroku, его функциональность можно проверить по ссылке (может долго грузится при первом подключении): https://intense-ocean-97811.herokuapp.com/apidocs/  
(https://10minutemail.net/ - почта на 10 минут, что бы не засорять вашу основную)
Подробнее о модулях и их endpoints
1) User. 
Create.  
Поскольку использование баз данных было запрещено условием, сохранение пользовательских  
данных было реализовано как работа с .json файлами. Поскольку сохранять все данные в одном файле нерационально, ввиду сопряженных проблем с конкурентным доступом, прозводительностью доступа к информации и другими, файлы сохраняются по такому алгоритму:  
1. На основе email-а пользователя обчислить hash  
2. Взять от полученного hash-a остаток от деления на число (в приложении это число равняется 5 * 10^6)  
3. Записать информацию в файл с полученным номером  
4. В случае коллизии, дозаписать новый email к уже записаному.  
  
Не сложно заметить, что описанный механизм повторяет идею, на основе которой работают хэш-таблицы.  
Все .json файлы сохраняются в одну директорию user_data. Интуитивно, хочется разделить эту директорию на поддиректории, с целью образования древовидной структры, что должно было бы упростить поиск файлов до сложности O(log(n)), но в реальности такого прироста не пройзойдет, поскольку ОС "под капотом" не выполняет поиск линейным сканированием. Ссылка на результаты сравнения записи и чтения 10 млн. файлов в плоскую и вложенную структуру директорий: https://medium.com/@hartator/benchmark-deep-directory-structure-vs-flat-directory-structure-to-store-millions-of-files-on-ext4-cac1000ca28.   
Пароль пользователя не хранится в открытом виде, а хешируется. Помимо информации про email и пароль, у пользователя сохраняется метка "is_activated", которая показывает подтвердил ли пользователь свой email. Что бы пользователь не ждал, пока ему отправится письмо, это делает отдельный worker в бэкграунде. Что бы данный worker получил информацию про email пользователя и токен подтверждения, используется distributed task queue Celery. Celery, при помощи брокера сообщений RabbitMQ, доставляет это сообщение для worker-a  
Login.  
Для аутентификации пользователя используется Json Web Token. В payload токена лежит email, метка 'is_activated' и время истечения токена (которое равняется 15 минутам)  
 	user/confirm/<token>  
 Endpoint, который активирует аккаунт пользователя и меняет метку 'is_activated' с False на True. На почту пользователю присылается уже готовая ссылка на этот endpoint.  
2) btcRate  
	Модуль работает с api, который предоставляет криптовалютная биржа CoinBase. Поскольку котировки биржи обновляются раз в минуту, то нет нужды делать запрос на биржу при каждом запросе пользователя. Поэтому, при инициализации модуль запускает отдельный thread, в котором ровно раз в 60 секунд делается запрос на биржу и сохраняется результат, который и отдается пользователям при запросах. Модуль проверяет JWT, который передает пользователь. В случае, если пользователь не активировал свой email, модуль не вернет пользователю информацию о курсе.  
Unit-tests  
Помимо самих модулей было написано два юнит теста, которые проверяют:  
1. Попытку получить информацию о курсе не авторизовавшись.  
2. Зарегестрироваться, залогиниться, получить информацию о курсе, активировать почту, получить информацию о курсе  

Пароли и токены передаются в header-ах http-запросов.  
"Соль" для jwt, и токена подтвержедния email-a берется из переменных окружения  
Endpoint-ы задокументированы при помощи swagger-a.  

